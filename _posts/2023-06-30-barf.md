---
layout: post
title:  "Bundle Adjusting Neural Radiance Fields in Nerfstudio"
date:   2023-06-30 02:18:45 +0100
categories: page
github: https://github.com/maturk/BARF-nerfstudio
---
<link href="{{ site.baseurl }}/assets/css/twentytwenty.css" rel="stylesheet" type="text/css" />
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
 <link rel="stylesheet" href="/assets/css/styles.css">
<div style="margin-top: 2em"></div>
<div class="row">
  <div class = "column">
    <p class="project-links">
        <svg class="svg-icon grey"><use xlink:href="{{ '/assets/minima-social-icons.svg#github' | relative_url }}"></use></svg>
        <a href="{{ page.github }}" target="_blank">GitHub link</a>
    </p> 
    </div>
    <div class = "column">
    <p class="project-links">
        <svg class="svg-icon grey"><use xlink:href="{{ '/assets/minima-social-icons.svg#pdf' | relative_url }}"></use></svg>
    </p> 
    </div>
<p>Training neural radiance fields with bad camera poses is a difficult problem. Conventional NERF pipelines always rely on traditional and expensive SfM algorithms for pose initialization, and a long term goal in computer vision research would be to achieve photorealistic 3D reconstruction and pose estimation on the fly. I, along with a few open-source contributors, implemented a few recent methods that tried to tackle this problem in Nerfstudio, an open source NERF platform. We implemented 3 different methods and they are all available through the <a href="https://github.com/maturk/BARF-nerfstudio">Github</a> link. Here I explain some of the methods.</p>

<p>We implemented the first paper that tried to do simultaneous pose estimation and NERF reconstruction: <a href=" https://arxiv.org/abs/2104.06405">BARF: Bundle-Adjusting Neural Radiance Fields</a>. The paper suggested a coarse-to-fine optimization of a frequency based encoder that would allow gradual scene reconstruction whilst limiting the magitude of backpropogated gradients to the camera extrinsics. Although the method works for a few test scenes, it is quite unusable due to its slow training time. Therefore, I implemented the same coarse-to-fine optimization strategy with the faster Instant-NGP hashgrid architecture. This is achieved by masking the active feature levels based on the equation proposed in BARF (equation 14). I tested my implementation by adding 0.1 STD gaussian noise to initial camera pose translation and rotation and evaluated the reconstruction quality of an optimized NeRF (based on Nerfstudio's Nerfacto model) with this strategy and with naive backpropogated gradients. 
</p>

<p>Like often in research, things move fast. Shortly after I finished my hashgrid BARF implementation, another paper <a href="https://arxiv.org/abs/2302.01571">Robust Camera Pose Refinement for Multi-Resolution Hash Encoding</a> showed up at PMLR. Instead of directly regulating the active levels in a hashgrid, they proposed a coarse-to-fine optimization strategy for the learning rate schedulers of each feature level. The paper showed that this method helped smoothen and converge to better results in optimization. Since the implementation was already very similar to my previous work, we also implemented this new method for comparison. All three methods, named "barf-freq" "barf-hash" "barf-grad" respectively, are available on the github repository. Here are a few training videos.</p>

<center>
<iframe width="560" height="315" src="{{ site.baseurl }}/assets/images/barf/barfVid.mp4" title="BARF vs Nerfacto" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
</center>

<br><br>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<script src="{{ site.baseurl }}/assets/jquery.twentytwenty.js"></script>
<script src="{{ site.baseurl }}/assets/bootstrap.min.js"></script>
<script src="{{ site.baseurl }}/assets/jquery.event.move.js"></script>
<script>
$(window).load(function(){$(".twentytwenty-container").twentytwenty({default_offset_pct: 0.5});});
</script>